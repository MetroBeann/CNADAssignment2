<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gait Analysis System</title>
    <!-- Updated CSP to allow all required resources -->
    <meta http-equiv="Content-Security-Policy" content="
    default-src 'self' https://cdn.jsdelivr.net;
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net;
    style-src 'self' 'unsafe-inline';
    frame-src 'self' https://www.youtube.com;
    img-src 'self' data: blob:;
    media-src 'self' blob: data:;
    connect-src 'self' https: wss: blob:;
    worker-src 'self' blob:;
    wasm-src 'self' 'unsafe-eval' https://cdn.jsdelivr.net;"
>

    <!-- Load MediaPipe libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <!-- Add MediaPipe configuration -->
    <script>
        window.onload = function() {
            if (typeof Pose === 'undefined') {
                console.error('MediaPipe Pose not loaded');
                const errorMsg = document.getElementById('error-message');
                if (errorMsg) {
                    errorMsg.textContent = 'Required libraries not loaded. Please refresh the page.';
                    errorMsg.style.display = 'block';
                }
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Increased base font size for better readability */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 18px;
            /* Increased base font size */
            line-height: 1.6;
            /* Improved line height for readability */
        }

        body {
            background-color: #f5f5f5;
            padding: 2rem;
            /* Increased contrast */
            color: #333;
        }

        .page-container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            gap: 2rem;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .gif-sidebar {
            width: 350px;
            /* Increased width */
            position: sticky;
            top: 2rem;
            align-self: flex-start;
        }

        .gif-container {
            background: white;
            border-radius: 12px;
            /* Increased border radius */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            /* Enhanced shadow */
            padding: 1.5rem;
            margin-bottom: 2rem;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .gif-container video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: opacity 0.3s ease;
        }

        .gif-caption {
            text-align: center;
            margin-top: 1.5rem;
            font-size: 1.2rem;
            /* Increased font size */
            color: #333;
            /* Darker color for better contrast */
            font-weight: 500;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .card-title {
            font-size: 2.2rem;
            /* Increased title size */
            font-weight: bold;
            margin-bottom: 1.5rem;
            color: #1a1a1a;
            /* Darker color for better contrast */
        }

        .instructions {
            background-color: #e6f3ff;
            /* Lighter blue background */
            border-left: 6px solid #2563eb;
            /* Thicker border */
            padding: 1.5rem;
            margin-bottom: 2rem;
            border-radius: 0 12px 12px 0;
        }

        .instructions h2 {
            color: #1e40af;
            margin-bottom: 1rem;
            font-size: 1.8rem;
            /* Increased size */
        }

        .instructions ol {
            margin-left: 2rem;
            color: #1e3a8a;
            font-size: 1.2rem;
            /* Increased list item size */
        }

        .instructions li {
            margin-bottom: 1rem;
            /* Increased spacing between items */
            padding-left: 0.5rem;
        }

        .timer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            /* Increased opacity */
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-size: 2rem;
            /* Increased timer size */
            font-weight: bold;
            z-index: 10;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 480px;
            background: #f0f0f0;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 1.5rem;
            border: 3px solid #e5e7eb;
            /* Added border */
        }

        #video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .path-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            /* Increased opacity */
            padding: 15px;
            border-radius: 8px;
            font-size: 1.1rem;
            /* Increased legend text size */
            border: 2px solid #e5e7eb;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 25px;
            /* Increased size */
            height: 4px;
            /* Increased thickness */
            margin-right: 12px;
        }

        .controls {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 1rem 2rem;
            /* Increased padding */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.8rem;
            font-size: 1.3rem;
            /* Increased button text size */
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: #2563eb;
            color: white;
        }

        .btn-primary:hover {
            background-color: #1d4ed8;
        }

        .btn-secondary {
            background-color: #4b5563;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #374151;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            /* Increased minimum width */
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .metric-title {
            font-size: 1.3rem;
            /* Increased metric title size */
            color: #4b5563;
            margin-bottom: 0.8rem;
        }

        .metric-value {
            font-size: 1.8rem;
            /* Increased metric value size */
            font-weight: bold;
            color: #111827;
        }

        .assessment-report {
            background: #f8fafc;
            padding: 2rem;
            border-radius: 12px;
            margin-top: 2rem;
            border: 2px solid #e5e7eb;
        }

        .assessment-report h2 {
            color: #0f172a;
            margin-bottom: 1.5rem;
            font-size: 2rem;
            /* Increased heading size */
        }

        .health-score {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            margin: 1.5rem 0;
            color: #0f172a;
        }

        .health-score span {
            font-size: inherit;
            font-weight: inherit;
        }

        .recommendations {
            margin-top: 2rem;
        }

        .recommendations h3 {
            font-size: 1.6rem;
            /* Increased recommendations heading */
            color: #1e40af;
            margin-bottom: 1rem;
        }

        .recommendations ul {
            list-style-type: disc;
            margin-left: 2rem;
        }

        .recommendations li {
            font-size: 1.2rem;
            /* Increased recommendation text size */
            margin-bottom: 1rem;
            color: #333;
        }

        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            /* Increased countdown size */
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 3rem;
            border-radius: 50%;
            width: 250px;
            height: 250px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .error-message {
            background-color: #fee2e2;
            color: #991b1b;
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            font-size: 1.3rem;
            /* Increased error message size */
            font-weight: 500;
        }

        .shortcuts-info {
            margin-top: 2rem;
            padding: 1.5rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .shortcuts-info p {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .shortcuts-info ul {
            list-style-type: none;
            margin-left: 1rem;
        }

        .shortcuts-info li {
            font-size: 1.2rem;
            margin-bottom: 0.8rem;
            color: #4b5563;
        }

        /* Media Queries for Responsiveness */
        @media (max-width: 1200px) {
            .page-container {
                flex-direction: column;
            }

            .gif-sidebar {
                width: 100%;
                max-width: 400px;
                margin: 0 auto;
            }
        }

        @media (max-width: 768px) {
            * {
                font-size: 16px;
                /* Slightly smaller base font on mobile */
            }

            .card-title {
                font-size: 1.8rem;
            }

            .btn {
                padding: 0.8rem 1.5rem;
                font-size: 1.1rem;
            }
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .audio-control {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .audio-control:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .audio-control svg {
            width: 24px;
            height: 24px;
        }

        .audio-control.playing {
            color: #2563eb;
        }

        .restart-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            display: none;
            align-items: center;
            justify-content: center;
            margin-left: 0.5rem;
        }

        .restart-button.visible {
            display: flex;
        }

        .back-button {
    position: fixed;
    top: 2rem;
    left: 2rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    background-color: #2563eb;
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 600;
    transition: background-color 0.2s;
    z-index: 100;
}

.back-button:hover {
    background-color: #1d4ed8;
}

.back-button svg {
    width: 20px;
    height: 20px;
}
    </style>
</head>

<body>
    <a href="http://localhost:8002" class="back-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
        Back
    </a>
    <div class="page-container">
        <!-- Main Content Section -->
        <div class="main-content">
            <div class="container">
                <div class="card">
                    <h1 class="card-title">Gait Analysis Dashboard</h1>

                    <!-- Instructions Card -->
                    <div class="instructions">
                        <h2>Test Instructions</h2>
                        <button class="audio-control" data-audio-src="audio/instruction.MOV"
                            aria-label="Play Instructions Audio">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                            </svg>
                        </button>
                        <button class="restart-button" aria-label="Restart Audio">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 2v6h6"></path>
                                <path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path>
                            </svg>
                        </button>
                        <ol>
                            <li>Clear a straight path of approximately 20 feet (6 meters) in front of your camera</li>
                            <li>Position yourself at one end of the path, facing the camera</li>
                            <li>When ready, click "Start Analysis"</li>
                            <li>After the 3-second countdown, walk naturally towards the other end</li>
                            <li>Turn around and walk back when you reach the end</li>
                            <li>Continue walking for the full 20 seconds</li>
                            <li>The analysis will stop automatically and show your results</li>
                        </ol>
                    </div>

                    <!-- YouTube Video Embed -->
                    <div class="video-embed-container" style="text-align: center; margin-bottom: 1.5rem;">
                        <iframe width="100%" height="400"
                            src="https://www.youtube.com/embed/JmAARbHd9pc?si=O45uFdO_hf77cYsa&amp;start=4"
                            title="YouTube video player" frameborder="0"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
                        </iframe>
                    </div>

                    <!-- Video Analysis Container -->
                    <div class="video-container">
                        <div id="timer" class="timer" style="display: none;">20</div>
                        <div id="countdown" class="countdown" style="display: none;">3</div>
                        <video id="video" playsinline></video>
                        <canvas id="canvas"></canvas>
                        <canvas id="pathCanvas" class="path-canvas"></canvas>

                        <!-- Path Legend -->
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FF0000"></div>
                                <span>Head Path</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #00FF00"></div>
                                <span>Hip Center Path</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #0000FF"></div>
                                <span>Foot Path</span>
                            </div>
                        </div>

                        <!-- Error Message Container -->
                        <div id="error-message" class="error-message" style="display: none;"></div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="controls">
                        <button id="startBtn" class="btn btn-primary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            Start Analysis
                        </button>
                        <button id="resetBtn" class="btn btn-secondary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M1 4v6h6"></path>
                                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                            </svg>
                            Reset
                        </button>
                    </div>

                    <!-- Metrics Grid -->
                    <div class="metrics-grid" id="metricsGrid"></div>

                    <!-- Assessment Report -->
                    <div id="assessmentReport" class="assessment-report">
                        <h2>Gait Assessment Report</h2>
                        <button class="audio-control" aria-label="Play Report Audio">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                            </svg>
                        </button>
                        <button class="restart-button" aria-label="Restart Audio">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 2v6h6"></path>
                                <path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path>
                            </svg>
                        </button>
                        <div class="health-score">
                            Overall Health Score: <span id="healthScore">0</span>/100
                        </div>
                        <div class="recommendations">
                            <h3>Recommendations:</h3>
                            <ul id="recommendationsList"></ul>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- GIF Sidebar -->
        <div class="gif-sidebar">
            <div class="gif-container">
                <video id="stateGif" autoplay loop muted playsinline>
                    <source src="GIFS/default.mp4" type="video/mp4">
                </video>
            </div>
            <p id="gifCaption" class="gif-caption">Waiting to start analysis...</p>
        </div>
    </div>

    <!-- Keyboard Shortcuts Info -->
    <div class="shortcuts-info">
        <p>Keyboard Shortcuts:</p>
        <ul>
            <li>Space: Start Analysis</li>
            <li>R: Reset</li>
        </ul>
    </div>

    <script>
        // Canvas contexts initialization
        const ctx = document.getElementById('canvas').getContext('2d');
        const pathCtx = document.getElementById('pathCanvas').getContext('2d');

        // Core variables
        let isRecording = false;
        let hasCamera = false;
        let previousPose = null;
        let frameCount = 0;
        let stepCount = 0;
        let startTime = null;
        let testDuration = 20; // Duration in seconds
        let countdownDuration = 3; // Countdown before start
        let timerInterval;
        let countdownInterval;
        let audioController;


        // Audio Controller Class
        class AudioController {
            constructor() {
                this.currentAudio = null;
                this.activeButton = null;
                this.activeRestartButton = null;
                this.audioCache = {
                    belowavg: null,
                    decent: null,
                    great: null
                };
                this.initializeEventListeners();
                this.preloadAudios();
            }

            preloadAudios() {
                // Preload all audio files with updated paths
                this.audioCache.belowavg = new Audio('audio/belowavg.MOV');
                this.audioCache.decent = new Audio('audio/decent.MOV');
                this.audioCache.great = new Audio('audio/great.MOV');
            }


            initializeEventListeners() {
                const audioButtons = document.querySelectorAll('.audio-control');
                audioButtons.forEach(button => {
                    button.addEventListener('click', () => this.handleAudioControl(button));
                });

                const restartButtons = document.querySelectorAll('.restart-button');
                restartButtons.forEach(button => {
                    button.addEventListener('click', () => this.restartAudio());
                });
            }

            handleAudioControl(button) {
                const audioSrc = button.dataset.audioSrc;
                if (!audioSrc) return;

                const restartButton = button.nextElementSibling;

                if (this.currentAudio) {
                    if (this.activeButton === button) {
                        this.pauseAudio();
                        return;
                    } else {
                        this.stopAudio();
                    }
                }

                // Use cached audio if available
                const audioType = this.getAudioType(audioSrc);
                if (audioType && this.audioCache[audioType]) {
                    this.currentAudio = this.audioCache[audioType];
                } else {
                    this.currentAudio = new Audio(audioSrc);
                }

                this.activeButton = button;
                this.activeRestartButton = restartButton;

                this.currentAudio.addEventListener('ended', () => {
                    this.resetButtonState();
                });

                this.currentAudio.addEventListener('playing', () => {
                    button.classList.add('playing');
                    restartButton.classList.add('visible');
                });

                this.currentAudio.addEventListener('pause', () => {
                    button.classList.remove('playing');
                });

                this.playAudio();
            }

            getAudioType(audioSrc) {
                if (audioSrc.includes('belowavg')) return 'belowavg';
                if (audioSrc.includes('decent')) return 'decent';
                if (audioSrc.includes('great')) return 'great';
                return null;
            }

            playAudio() {
                if (this.currentAudio) {
                    // Reset the audio to start if it was previously played
                    this.currentAudio.currentTime = 0;
                    this.currentAudio.play()
                        .catch(error => {
                            console.error('Error playing audio:', error);
                            this.resetButtonState();
                        });
                }
            }

            pauseAudio() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.activeButton.classList.remove('playing');
                }
            }

            stopAudio() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                    this.resetButtonState();
                }
            }

            restartAudio() {
                if (this.currentAudio) {
                    this.currentAudio.currentTime = 0;
                    this.playAudio();
                }
            }

            resetButtonState() {
                if (this.activeButton) {
                    this.activeButton.classList.remove('playing');
                }
                if (this.activeRestartButton) {
                    this.activeRestartButton.classList.remove('visible');
                }
            }
        }


        // GIF state management
        const gifStates = {
            initial: {
                path: 'GIFS/default.mp4',
                caption: 'Ready to analyze your gait! Click Start Analysis when ready.'
            },
            analyzing: {
                path: 'GIFS/waiting.mp4',
                caption: 'Analyzing your gait pattern...'
            },
            lowScore: {
                path: 'GIFS/shock.mp4',
                caption: 'Overall Health Score is Below Average, Retake the analysis or consult a doctor'
            },
            mediumScore: {
                path: 'GIFS/yay.mp4',
                caption: 'Overall Health Score is Decent, More To Go!'
            },
            highScore: {
                path: 'GIFS/swag.mp4',
                caption: 'Overall Health Score is Great, Keep It Up!'
            }
        };
        // Metrics tracking
        const metrics = {
            walkingSpeed: 0,
            stepLength: 0,
            cadence: 0,
            symmetry: 0,
            balance: 0
        };

        // Path tracking
        const pathHistory = {
            head: [],
            hipCenter: [],
            leftFoot: [],
            rightFoot: []
        };
        const maxPathLength = 50;

        // DOM Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const pathCanvas = document.getElementById('pathCanvas');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const errorMessage = document.getElementById('error-message');
        const metricsGrid = document.getElementById('metricsGrid');
        const timerDisplay = document.getElementById('timer');
        const countdownDisplay = document.getElementById('countdown');
        const assessmentReport = document.getElementById('assessmentReport');
        const healthScoreElement = document.getElementById('healthScore');
        const recommendationsList = document.getElementById('recommendationsList');

        // Set canvas sizes
        function initializeCanvases() {
            canvas.width = 640;
            canvas.height = 480;
            pathCanvas.width = 640;
            pathCanvas.height = 480;
        }

        // GIF State Management
        function updateGifState(state) {
            const stateVideo = document.getElementById('stateGif');
            const gifCaption = document.getElementById('gifCaption');

            // Add fade out effect
            stateVideo.style.opacity = '0';
            gifCaption.style.opacity = '0';

            setTimeout(() => {
                stateVideo.src = gifStates[state].path;
                gifCaption.textContent = gifStates[state].caption;

                // Add fade in effect
                stateVideo.style.opacity = '1';
                gifCaption.style.opacity = '1';

                // Ensure the video plays
                stateVideo.play().catch(function (error) {
                    console.log("Video play failed:", error);
                });
            }, 300);
        }

        // Metrics Display
        function updateMetricsDisplay() {
            metricsGrid.innerHTML = Object.entries(metrics).map(([key, value]) => `
        <div class="metric-card">
            <div class="metric-title">${key.charAt(0).toUpperCase() + key.slice(1)}</div>
            <div class="metric-value">${value.toFixed(2)}</div>
        </div>
    `).join('');
        }

        // Camera Initialization
        function initializeCamera() {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    video.srcObject = stream;
                    video.play();
                    hasCamera = true;
                    errorMessage.style.display = 'none';
                    updateGifState('initial');
                })
                .catch(err => {
                    errorMessage.textContent = 'Unable to access camera. Please ensure you have given permission.';
                    errorMessage.style.display = 'block';
                    hasCamera = false;
                });
        }

        // Countdown Management
        function startCountdown() {
            if (!hasCamera) {
                errorMessage.textContent = 'Camera not available. Please ensure camera access is granted.';
                errorMessage.style.display = 'block';
                return;
            }

            let count = countdownDuration;
            countdownDisplay.style.display = 'flex';
            countdownDisplay.textContent = count;

            countdownInterval = setInterval(() => {
                count--;
                countdownDisplay.textContent = count;

                if (count === 0) {
                    clearInterval(countdownInterval);
                    countdownDisplay.style.display = 'none';
                    startGaitAnalysis();
                }
            }, 1000);
        }

        // Main Analysis Functions
        async function startGaitAnalysis() {
            showLoadingIndicator();
            
            try {
                // Wait for MediaPipe to load
                if (typeof Pose === 'undefined') {
                    await new Promise((resolve, reject) => {
                        let attempts = 0;
                        const checkLibrary = setInterval(() => {
                            attempts++;
                            if (typeof Pose !== 'undefined') {
                                clearInterval(checkLibrary);
                                resolve();
                            }
                            if (attempts > 50) { // 5 seconds timeout
                                clearInterval(checkLibrary);
                                reject(new Error('MediaPipe failed to load'));
                            }
                        }, 100);
                    });
                }

                isRecording = true;
                startTime = Date.now();
                timerDisplay.style.display = 'block';
                updateGifState('analyzing');
                startTimer();

                const pose = new Pose({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                    }
                });

                pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                pose.onResults(onResults);

                const camera = new Camera(video, {
                    onFrame: async () => {
                        if (isRecording) {
                            await pose.send({ image: video });
                        }
                    },
                    width: 640,
                    height: 480
                });

                hideLoadingIndicator();
                await camera.start();

                setTimeout(() => {
                    stopAnalysis();
                    generateReport();
                }, testDuration * 1000);

            } catch (error) {
                console.error('Error in startGaitAnalysis:', error);
                handleAnalysisError(error);
            }
        }

        // Timer Management
        function startTimer() {
            let timeLeft = testDuration;
            timerDisplay.textContent = timeLeft;

            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = timeLeft;

                if (timeLeft === 0) {
                    clearInterval(timerInterval);
                }
            }, 1000);
        }

        // Pose Detection Results Handler
        function onResults(results) {
            if (!results.poseLandmarks) return;

            const landmarks = results.poseLandmarks;
            frameCount++;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updatePathHistory(landmarks);
            drawPath();
            drawSkeleton(landmarks);
            calculateMetrics(landmarks);
            updateMetricsDisplay();

            previousPose = landmarks;
        }

        // Path Tracking Functions
        function updatePathHistory(landmarks) {
            // Head tracking
            pathHistory.head.push({
                x: landmarks[0].x * pathCanvas.width,
                y: landmarks[0].y * pathCanvas.height
            });

            // Hip center tracking
            const hipCenterX = ((landmarks[23].x + landmarks[24].x) / 2) * pathCanvas.width;
            const hipCenterY = ((landmarks[23].y + landmarks[24].y) / 2) * pathCanvas.height;
            pathHistory.hipCenter.push({ x: hipCenterX, y: hipCenterY });

            // Feet tracking
            pathHistory.leftFoot.push({
                x: landmarks[31].x * pathCanvas.width,
                y: landmarks[31].y * pathCanvas.height
            });
            pathHistory.rightFoot.push({
                x: landmarks[32].x * pathCanvas.width,
                y: landmarks[32].y * pathCanvas.height
            });

            // Maintain path history length
            Object.keys(pathHistory).forEach(key => {
                if (pathHistory[key].length > maxPathLength) {
                    pathHistory[key].shift();
                }
            });
        }

        // Drawing Functions
        function drawPath() {
            pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
            Object.entries(pathHistory).forEach(([key, points]) => {
                const color = key === 'head' ? '#FF0000' :
                    key === 'hipCenter' ? '#00FF00' : '#0000FF';
                drawPathWithFade(points, color);
            });
        }

        function drawPathWithFade(points, color) {
            if (points.length < 2) return;
            for (let i = 1; i < points.length; i++) {
                const opacity = i / points.length;
                pathCtx.beginPath();
                pathCtx.moveTo(points[i - 1].x, points[i - 1].y);
                pathCtx.lineTo(points[i].x, points[i].y);
                pathCtx.strokeStyle = `rgba(${color.slice(1).match(/../g).map(hex => parseInt(hex, 16)).join(',')},${opacity})`;
                pathCtx.lineWidth = 3;
                pathCtx.stroke();
            }
        }

        function drawSkeleton(landmarks) {
            const connections = [
                [11, 12], [12, 24], [24, 23], [23, 11], // Torso
                [24, 26], [26, 28], [23, 25], [25, 27], // Legs
                [12, 14], [14, 16], [11, 13], [13, 15]  // Arms
            ];

            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 2;

            // Draw connections
            connections.forEach(([start, end]) => {
                ctx.beginPath();
                ctx.moveTo(landmarks[start].x * canvas.width, landmarks[start].y * canvas.height);
                ctx.lineTo(landmarks[end].x * canvas.width, landmarks[end].y * canvas.height);
                ctx.stroke();
            });

            // Draw landmarks
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc(landmark.x * canvas.width, landmark.y * canvas.height, 3, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF0000';
                ctx.fill();
            });
        }

        // Metrics Calculation Functions
        function calculateMetrics(landmarks) {
            if (!previousPose) return;

            // Step detection
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const prevLeftAnkle = previousPose[27];
            const prevRightAnkle = previousPose[28];

            if ((leftAnkle.y < prevLeftAnkle.y - 0.03) || (rightAnkle.y < prevRightAnkle.y - 0.03)) {
                stepCount++;
            }

            const timeElapsed = (Date.now() - startTime) / 1000;

            metrics.walkingSpeed = calculateWalkingSpeed(landmarks, previousPose);
            metrics.stepLength = calculateStepLength(landmarks);
            metrics.cadence = (stepCount / timeElapsed) * 60;
            metrics.symmetry = calculateGaitSymmetry(landmarks);
            metrics.balance = calculateBalanceScore(landmarks);
        }

        function calculateWalkingSpeed(landmarks, previousPose) {
            const hipCenter = {
                x: (landmarks[23].x + landmarks[24].x) / 2,
                y: (landmarks[23].y + landmarks[24].y) / 2
            };

            const prevHipCenter = {
                x: (previousPose[23].x + previousPose[24].x) / 2,
                y: (previousPose[23].y + previousPose[24].y) / 2
            };

            const distance = Math.sqrt(
                Math.pow(hipCenter.x - prevHipCenter.x, 2) +
                Math.pow(hipCenter.y - prevHipCenter.y, 2)
            );

            return distance * 30; // Approximate conversion to m/s
        }

        function calculateStepLength(landmarks) {
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            return Math.abs(leftAnkle.x - rightAnkle.x);
        }

        function calculateGaitSymmetry(landmarks) {
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];

            const leftLegAngle = Math.atan2(leftKnee.y - leftHip.y, leftKnee.x - leftHip.x);
            const rightLegAngle = Math.atan2(rightKnee.y - rightHip.y, rightKnee.x - rightHip.x);

            const symmetry = 100 - Math.abs(leftLegAngle - rightLegAngle) * 100;
            return Math.max(0, Math.min(100, symmetry));
        }

        function calculateBalanceScore(landmarks) {
            const hipCenter = {
                x: (landmarks[23].x + landmarks[24].x) / 2,
                y: (landmarks[23].y + landmarks[24].y) / 2
            };

            const head = landmarks[0];
            const deviation = Math.abs(head.x - hipCenter.x);

            const score = 100 - (deviation * 200);
            return Math.max(0, Math.min(100, score));
        }

        // Report Generation Functions
        function generateReport() {
            const healthScore = calculateOverallHealthScore();
            const recommendations = generateRecommendations(healthScore);

            // Update audio source based on score
            const audioControl = document.querySelector('.assessment-report .audio-control');
            if (audioControl) {
                // Remove any existing click event listeners
                const clone = audioControl.cloneNode(true);
                audioControl.parentNode.replaceChild(clone, audioControl);

                // Set the appropriate audio source based on the score
                if (healthScore <= 40) {
                    clone.dataset.audioSrc = "audio/belowavg.MOV";
                } else if (healthScore <= 70) {
                    clone.dataset.audioSrc = "audio/decent.MOV";
                } else {
                    clone.dataset.audioSrc = "audio/great.MOV";
                }
            }

            // Update GIF based on score
            if (healthScore <= 40) {
                updateGifState('lowScore');
            } else if (healthScore <= 70) {
                updateGifState('mediumScore');
            } else {
                updateGifState('highScore');
            }

            healthScoreElement.textContent = healthScore;
            recommendationsList.innerHTML = recommendations.map(rec => `<li>${rec}</li>`).join('');
            assessmentReport.style.display = 'block';

            // Reinitialize audio controller to pick up the new button
            new AudioController();
        }

        function calculateOverallHealthScore() {
            const weights = {
                walkingSpeed: 0.25,
                stepLength: 0.2,
                cadence: 0.2,
                symmetry: 0.2,
                balance: 0.15
            };

            let score = 0;
            Object.entries(metrics).forEach(([metric, value]) => {
                const normalizedValue = normalizeMetric(value, metric);
                score += normalizedValue * weights[metric];
            });

            return Math.round(score);
        }

        function normalizeMetric(value, metric) {
            const ranges = {
                walkingSpeed: { min: 0.8, max: 1.4, optimal: 1.2 },
                stepLength: { min: 0.5, max: 0.8, optimal: 0.65 },
                cadence: { min: 90, max: 120, optimal: 105 },
                symmetry: { min: 80, max: 100, optimal: 95 },
                balance: { min: 70, max: 100, optimal: 90 }
            };

            const range = ranges[metric];
            let score = 100 * (value - range.min) / (range.max - range.min);

            if (value > range.optimal) {
                score -= (value - range.optimal) / (range.max - range.optimal) * 20;
            }

            return Math.max(0, Math.min(100, score));
        }

        function generateRecommendations(score) {
            const recommendations = [];

            if (score < 60) {
                recommendations.push("Consider consulting a healthcare provider for a detailed gait assessment.");
            }

            if (metrics.walkingSpeed < 1.0) {
                recommendations.push("Your walking speed is below recommended levels. Try gradual walking exercises to build speed.");
            }

            if (metrics.balance < 85) {
                recommendations.push("Consider balance-improving exercises like tai chi or standing on one foot.");
            }

            if (metrics.symmetry < 90) {
                recommendations.push("Your gait shows some asymmetry. Strength training exercises might help improve this.");
            }

            if (metrics.cadence < 100) {
                recommendations.push("Try to take slightly more frequent steps while maintaining comfort.");
            }

            // Add personalized recommendations based on specific metrics
            if (metrics.stepLength < 0.6) {
                recommendations.push("Your steps are shorter than optimal. Practice taking longer strides in a controlled environment.");
            }

            // Add positive reinforcement for good metrics
            const goodMetrics = [];
            if (metrics.walkingSpeed >= 1.2) goodMetrics.push("walking speed");
            if (metrics.balance >= 90) goodMetrics.push("balance");
            if (metrics.symmetry >= 95) goodMetrics.push("gait symmetry");

            if (goodMetrics.length > 0) {
                recommendations.push(`Excellent ${goodMetrics.join(" and ")}! Keep maintaining these strong aspects of your gait.`);
            }

            if (recommendations.length === 0) {
                recommendations.push("Your gait patterns are within healthy ranges. Keep up your current activity level!");
            }

            return recommendations;
        }

        // Analysis Control Functions
        function stopAnalysis() {
            isRecording = false;
            clearInterval(timerInterval);
            timerDisplay.style.display = 'none';

            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }
        }

        function resetAnalysis() {
            // Reset all metrics
            Object.keys(metrics).forEach(key => metrics[key] = 0);

            // Clear path history
            Object.keys(pathHistory).forEach(key => pathHistory[key] = []);

            // Reset analysis state
            previousPose = null;
            frameCount = 0;
            stepCount = 0;

            // Reset UI elements
            assessmentReport.style.display = 'none';
            timerDisplay.style.display = 'none';
            updateMetricsDisplay();

            // Clear canvases
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);

            // Reset GIF state
            updateGifState('initial');

            // Stop current analysis and reinitialize camera
            stopAnalysis();
            initializeCamera();
        }

        // Error Handling Functions
        function handleAnalysisError(error) {
            console.error('Analysis Error:', error);
            errorMessage.textContent = 'An error occurred during analysis. Please try again.';
            errorMessage.style.display = 'block';
            stopAnalysis();
            updateGifState('initial');
        }

        function handleCameraError(error) {
            console.error('Camera Error:', error);
            errorMessage.textContent = 'Unable to access camera. Please check your permissions and try again.';
            errorMessage.style.display = 'block';
            hasCamera = false;
            updateGifState('initial');
        }
        // Add this function at the end of your script section
function showLoadingIndicator() {
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loadingIndicator';
    loadingDiv.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 8px;
        z-index: 1000;
    `;
    loadingDiv.textContent = 'Loading...';
    document.querySelector('.video-container').appendChild(loadingDiv);
}

function hideLoadingIndicator() {
    const loadingDiv = document.getElementById('loadingIndicator');
    if (loadingDiv) {
        loadingDiv.remove();
    }
}

        // Utility Functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Window Resize Handler
        const handleResize = debounce(() => {
            initializeCanvases();
            if (previousPose) {
                drawSkeleton(previousPose);
                drawPath();
            }
        }, 250);

        // Event Listeners
        function initializeEventListeners() {
            startBtn.addEventListener('click', startCountdown);
            resetBtn.addEventListener('click', resetAnalysis);
            window.addEventListener('resize', handleResize);

            // Add keyboard shortcuts
            document.addEventListener('keypress', (e) => {
                if (e.code === 'Space') {
                    if (!isRecording) {
                        startBtn.click();
                    }
                } else if (e.code === 'KeyR') {
                    resetBtn.click();
                }
            });
        }
        

        // Initialization
        function initialize() {
            initializeCanvases();
            initializeEventListeners();
            initializeCamera();
            updateMetricsDisplay();
        }


        // Start the application
        document.addEventListener('DOMContentLoaded', initialize);

        document.addEventListener('DOMContentLoaded', () => {
            audioController = new AudioController();
        });

        // Export functions for testing if needed
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = {
                calculateWalkingSpeed,
                calculateStepLength,
                calculateGaitSymmetry,
                calculateBalanceScore,
                calculateOverallHealthScore,
                normalizeMetric,
                generateRecommendations
            };
        }
    </script>
</body>

</html>